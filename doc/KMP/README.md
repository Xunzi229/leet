## 最金典的KMP算法 ##

* KMP算法, 字符串查找算法, 
可在一个主文本字符串S内查找一个词W的出现的位置

* KMP算法的核心是 根据 目标字符串W特性来避免重复匹配, 
达到更优的解法


## 匹配的词典, 前缀子集 后缀子集 ##
W词的拆分, 根据前缀和后缀计算当前位置的最大重复数据
譬如 一个单词 
```
A 
    前缀子集(排除最后一个字符)=> []
    后缀子集(排除第一个字符) => []
  所以最大匹配数是 0
```

```
AB 
    前缀子集(排除最后一个字符)=> [A]
    后缀子集(排除第一个字符) => [B]
  所以最大匹配数是 0
```

```
ABA
    前缀子集(排除最后一个字符)=> [A, AB]
    后缀子集(排除第一个字符) => [BA, A]
  所以最大匹配位数是 2
```

```
ABADA
    前缀子集(排除最后一个字符)=> [A, AB, ABA, ABAD]
    后缀子集(排除第一个字符) => [BADA, ADA, DA, A]
  所以最大匹配位数是 1
```

   
## 排序过程 ##
假设
```
    S = "XSADA ADACCEDSVSAD AWASDF ADACCVFFE"
    W = "ADACCV"
``` 
第一步
> 开始移动位置
每移动一次记录当前的index 和 最大匹配数
循环两次后移动到了这个位置
```
XSADA ADACCEDSVSAD AWASDF ADACCVFFE
  ADACCV

记录下去 
    index = 0  max = 0
    index = 1  max = 0
    index = 2  max = 1
    index = 3  max = 0

此时 C 和空格匹配不上, 则移动了3次 
    3 - 最大匹配数 1 = 2
    将W整体向后移动1位
XSADA ADACCEDSVSAD AWASDF ADACCVFFE
    ADACCV
   
此时D对应的空格 不匹配, 则继续移动
    1 该位置的最大匹配数是 0  1 - 0 = 1
XSADA ADACCEDSVSAD AWASDF ADACCVFFE
     ADACCV 

A 与空格不匹配, 继续移动
XSADA ADACCEDSVSAD AWASDF ADACCVFFE
      ADACCV    
```
* 思考的是 中间会少很多次匹配的循环
* 为什么要跳过最大匹配数?
* 如果我们弄明白为什么跳过最大匹配数的同时 也要考虑最大匹配数到底是什么


## 什么是最大匹配数 ##
W 串在进行移动的时候
譬如 ADACCV 
在index = 3 的时候 , 因为前面的最大匹配串是1

这也是自身和自身的匹配, 
```
ADAC
当移动一个位置的时候 
ADAC
 ADAC  无效匹配

移动了1个位置
```

```
ADAC
  ADAC
  此种情况是直接跳过D 来到A处进行匹配

直接移动2个位置
```

这就和最大匹配数有关了, 首先本身是不能和本身匹配的, 所以为什么要去掉最前面的一位 和最后一位
1. 最大其实是有顺序的, 是有特点的
2. 当一个字符的时候, 最大是 0
3. 当两个字符的时候, 最大可能是 1
4. 当三个字符的时候, 最大可能是 2 
    * 匹配是2, 说明 01 位置 和  12位置字符串相同啊, 所以跳的话, 直接移动一个位置就能直接匹配上
    * 如果最大可能数是 1
    * 那么只有可能是 0 和 2位置字符相同, 如果跳的话, 需要跳两位, 才能保证移动到最佳匹配位置
---
以此类推

以上就是KMP的核心思想


## 其余就是 ##
* 使用字典记录每个index位置的最大匹配数, 保证用的时候能直接拿到
* 最后的index 的计算

  



